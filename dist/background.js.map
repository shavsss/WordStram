{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://wordstream/./src/services/caption-detectors/shared/language-map.ts","webpack://wordstream/./src/services/gemini/gemini-service.ts","webpack://wordstream/webpack/bootstrap","webpack://wordstream/webpack/runtime/define property getters","webpack://wordstream/webpack/runtime/hasOwnProperty shorthand","webpack://wordstream/webpack/runtime/make namespace object","webpack://wordstream/./src/background/index.ts"],"sourcesContent":["export const LANGUAGE_MAP = {\n    'auto': 'Auto Detect',\n    'af': 'Afrikaans',\n    'sq': 'Albanian',\n    'am': 'Amharic',\n    'ar': 'Arabic',\n    'hy': 'Armenian',\n    'az': 'Azerbaijani',\n    'eu': 'Basque',\n    'be': 'Belarusian',\n    'bn': 'Bengali',\n    'bs': 'Bosnian',\n    'bg': 'Bulgarian',\n    'ca': 'Catalan',\n    'ceb': 'Cebuano',\n    'ny': 'Chichewa',\n    'zh-CN': 'Chinese (Simplified)',\n    'zh-TW': 'Chinese (Traditional)',\n    'co': 'Corsican',\n    'hr': 'Croatian',\n    'cs': 'Czech',\n    'da': 'Danish',\n    'nl': 'Dutch',\n    'en': 'English',\n    'eo': 'Esperanto',\n    'et': 'Estonian',\n    'tl': 'Filipino',\n    'fi': 'Finnish',\n    'fr': 'French',\n    'fy': 'Frisian',\n    'gl': 'Galician',\n    'ka': 'Georgian',\n    'de': 'German',\n    'el': 'Greek',\n    'gu': 'Gujarati',\n    'ht': 'Haitian Creole',\n    'ha': 'Hausa',\n    'haw': 'Hawaiian',\n    'he': 'Hebrew',\n    'hi': 'Hindi',\n    'hmn': 'Hmong',\n    'hu': 'Hungarian',\n    'is': 'Icelandic',\n    'ig': 'Igbo',\n    'id': 'Indonesian',\n    'ga': 'Irish',\n    'it': 'Italian',\n    'ja': 'Japanese',\n    'jv': 'Javanese',\n    'kn': 'Kannada',\n    'kk': 'Kazakh',\n    'km': 'Khmer',\n    'ko': 'Korean',\n    'ku': 'Kurdish',\n    'ky': 'Kyrgyz',\n    'lo': 'Lao',\n    'la': 'Latin',\n    'lv': 'Latvian',\n    'lt': 'Lithuanian',\n    'lb': 'Luxembourgish',\n    'mk': 'Macedonian',\n    'mg': 'Malagasy',\n    'ms': 'Malay',\n    'ml': 'Malayalam',\n    'mt': 'Maltese',\n    'mi': 'Maori',\n    'mr': 'Marathi',\n    'mn': 'Mongolian',\n    'my': 'Myanmar (Burmese)',\n    'ne': 'Nepali',\n    'no': 'Norwegian',\n    'ps': 'Pashto',\n    'fa': 'Persian',\n    'pl': 'Polish',\n    'pt': 'Portuguese',\n    'pa': 'Punjabi',\n    'ro': 'Romanian',\n    'ru': 'Russian',\n    'sm': 'Samoan',\n    'gd': 'Scots Gaelic',\n    'sr': 'Serbian',\n    'st': 'Sesotho',\n    'sn': 'Shona',\n    'sd': 'Sindhi',\n    'si': 'Sinhala',\n    'sk': 'Slovak',\n    'sl': 'Slovenian',\n    'so': 'Somali',\n    'es': 'Spanish',\n    'su': 'Sundanese',\n    'sw': 'Swahili',\n    'sv': 'Swedish',\n    'tg': 'Tajik',\n    'ta': 'Tamil',\n    'te': 'Telugu',\n    'th': 'Thai',\n    'tr': 'Turkish',\n    'uk': 'Ukrainian',\n    'ur': 'Urdu',\n    'ug': 'Uyghur',\n    'uz': 'Uzbek',\n    'vi': 'Vietnamese',\n    'cy': 'Welsh',\n    'xh': 'Xhosa',\n    'yi': 'Yiddish',\n    'yo': 'Yoruba',\n    'zu': 'Zulu'\n};\nexport function normalizeLanguageCode(code) {\n    // Normalize Hebrew language codes - all variants map to 'he'\n    if (code === 'iw' || code === 'he-IL') {\n        return 'he';\n    }\n    // Normalize Indonesian codes\n    if (code === 'in') {\n        return 'id';\n    }\n    // Normalize Javanese codes\n    if (code === 'jw') {\n        return 'jv';\n    }\n    return code || 'auto';\n}\nexport function getLanguageCode(languageName) {\n    const cleanName = languageName.trim().toLowerCase();\n    const entry = Object.entries(LANGUAGE_MAP).find(([_, name]) => cleanName.includes(name.toLowerCase()));\n    return normalizeLanguageCode(entry === null || entry === void 0 ? void 0 : entry[0]) || 'en';\n}\n","/// <reference types=\"chrome\"/>\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Default configuration for Gemini API\nexport const GEMINI_CONFIG = {\n    apiKey: 'AIzaSyCLBHKWu7l78tS2xVmizicObSb0PpUqsxM', // Using the same API key as Google Translate\n    model: 'gemini-pro-latest', // תמיד מצביע על הגרסה העדכנית ביותר הזמינה\n    fallbackModel: 'gemini-1.5-pro', // המודל העדכני והחזק ביותר הזמין רשמית (2024)\n    secondaryFallbackModel: 'gemini-1.5-flash', // המודל המהיר והעדכני ביותר לתרחישי גיבוי\n    maxTokens: 8192 // הגדלת מספר הטוקנים המקסימלי לתשובות ארוכות ומפורטות יותר\n};\n/**\n * Send a query to Gemini API with conversation history\n */\nexport function sendToGemini(query, history, videoTitle) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Try to get API key from Chrome Storage or use the same as Google Translate\n            const storageResult = yield chrome.storage.local.get(['geminiApiKey']);\n            const apiKey = storageResult.geminiApiKey || GEMINI_CONFIG.apiKey;\n            console.log(\"Using API key for Gemini:\", apiKey.substring(0, 10) + \"...\");\n            if (!apiKey) {\n                return \"API key not configured. Please set your Gemini API key in the extension settings.\";\n            }\n            // Instead of making a direct fetch request, use chrome.runtime.sendMessage to send via background script\n            const response = yield chrome.runtime.sendMessage({\n                action: 'gemini',\n                message: query,\n                history: history,\n                videoTitle: videoTitle\n            });\n            if (!response.success) {\n                throw new Error(response.error || 'Failed to get response from Gemini');\n            }\n            return response.answer || 'No answer received';\n        }\n        catch (error) {\n            console.error('Error calling Gemini API:', error);\n            return \"Sorry, I couldn't process your request at this time. Please try again later.\";\n        }\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"chrome\"/>\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { normalizeLanguageCode } from '@/services/caption-detectors/shared/language-map';\nimport { GEMINI_CONFIG } from '@/services/gemini/gemini-service';\n// Initialize extension\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('WordStream: Background script installed and running');\n    // Initialize default settings if they don't exist\n    chrome.storage.sync.get(['settings'], (result) => {\n        if (!result.settings) {\n            const defaultSettings = {\n                targetLanguage: 'en',\n                autoTranslate: true,\n                notifications: true,\n                darkMode: false\n            };\n            chrome.storage.sync.set({ settings: defaultSettings }, () => {\n                console.log('WordStream: Default settings initialized');\n            });\n        }\n    });\n});\n// Add persistent connection check\nlet isBackgroundActive = true;\nchrome.runtime.onConnect.addListener((port) => {\n    console.log('WordStream: New connection established', port.name);\n    port.onDisconnect.addListener(() => {\n        console.log('WordStream: Connection disconnected', port.name);\n    });\n});\n// Handle messages from content scripts\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    var _a;\n    console.log('WordStream: Received message', request.action || request.type);\n    if (!isBackgroundActive) {\n        console.error('WordStream: Background script is not active');\n        sendResponse({ success: false, error: 'Background script is not active' });\n        return false;\n    }\n    if (request.type === 'PING') {\n        sendResponse({ success: true, message: 'Background script is active' });\n        return true; // Will respond asynchronously\n    }\n    if (request.type === 'TRANSLATE_WORD') {\n        handleTranslation(request.payload).then(sendResponse);\n        return true; // Will respond asynchronously\n    }\n    if (request.action === 'gemini') {\n        console.log('WordStream: Processing Gemini request', {\n            message: request.message,\n            historyLength: (_a = request.history) === null || _a === void 0 ? void 0 : _a.length,\n            videoId: request.videoId\n        });\n        handleGeminiRequest(request)\n            .then((result) => {\n            console.log('WordStream: Gemini response generated successfully');\n            sendResponse(result);\n        })\n            .catch(error => {\n            console.error('WordStream: Error generating Gemini response:', error);\n            sendResponse({\n                success: false,\n                answer: null,\n                error: error instanceof Error ? error.message : 'Unknown error processing Gemini request'\n            });\n        });\n        return true; // Will respond asynchronously\n    }\n    if (request.type === 'UPDATE_LANGUAGE_SETTINGS') {\n        handleLanguageSettingsUpdate(request.payload)\n            .then((result) => {\n            console.log('WordStream: Language settings update result', result);\n            sendResponse(result);\n        })\n            .catch(error => {\n            console.error('WordStream: Language settings update error', error);\n            sendResponse({\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error updating language settings'\n            });\n        });\n        return true;\n    }\n});\n// פונקציית עזר לטיפול בשגיאות\nfunction safeStringifyError(error) {\n    try {\n        if (error instanceof Error) {\n            return error.message;\n        }\n        if (typeof error === 'string') {\n            return error;\n        }\n        if (error && typeof error === 'object') {\n            try {\n                return JSON.stringify(error);\n            }\n            catch (e) {\n                return 'Object error - cannot stringify';\n            }\n        }\n        return String(error);\n    }\n    catch (e) {\n        return 'Unknown error - cannot format';\n    }\n}\n// Use a constant API key\nconst GOOGLE_TRANSLATE_API_KEY = 'AIzaSyCLBHKWu7l78tS2xVmizicObSb0PpUqsxM';\nfunction handleTranslation(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        try {\n            // Validate input\n            if (!data.text || typeof data.text !== 'string') {\n                console.error('WordStream: Invalid text for translation:', data.text);\n                return {\n                    success: false,\n                    error: 'Invalid or missing text for translation'\n                };\n            }\n            // Log text to translate\n            console.log(`WordStream: Translating text: \"${data.text.substring(0, 30)}${data.text.length > 30 ? '...' : ''}\"`);\n            // Get settings and ensure we have a valid target language\n            const settingsResult = yield chrome.storage.sync.get(['settings']);\n            console.log('WordStream: Retrieved settings for translation:', settingsResult);\n            const settings = settingsResult.settings || { targetLanguage: 'en' };\n            let targetLang = data.targetLang || settings.targetLanguage || 'en';\n            // Ensure target language is in correct format and normalized\n            targetLang = normalizeLanguageCode(targetLang.toLowerCase().trim());\n            console.log('WordStream: Using target language for translation:', targetLang);\n            // Construct request URL\n            const requestUrl = `https://translation.googleapis.com/language/translate/v2?key=${GOOGLE_TRANSLATE_API_KEY}`;\n            console.log('WordStream: Sending translation request to Google API');\n            // הבקשה הבסיסית שעבדה\n            try {\n                const response = yield fetch(requestUrl, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({\n                        q: data.text,\n                        target: targetLang\n                    }),\n                });\n                // Log response status\n                console.log(`WordStream: Translation API response status: ${response.status} ${response.statusText}`);\n                if (!response.ok) {\n                    const errorText = yield response.text().catch(e => 'Could not read error response');\n                    console.error(`WordStream: Translation request failed (${response.status}):`, errorText);\n                    throw new Error(`Translation request failed (${response.status}): ${errorText}`);\n                }\n                // Parse response\n                try {\n                    const translationResult = yield response.json();\n                    console.log('WordStream: Translation result received');\n                    if (!((_b = (_a = translationResult.data) === null || _a === void 0 ? void 0 : _a.translations) === null || _b === void 0 ? void 0 : _b[0])) {\n                        console.error('WordStream: Invalid translation response structure:', translationResult);\n                        throw new Error('Invalid translation response structure');\n                    }\n                    // Return successful translation\n                    return {\n                        success: true,\n                        translation: translationResult.data.translations[0].translatedText,\n                        detectedSourceLanguage: translationResult.data.translations[0].detectedSourceLanguage\n                    };\n                }\n                catch (parseError) {\n                    console.error('WordStream: Error parsing translation response:', safeStringifyError(parseError));\n                    throw new Error(`Error parsing translation response: ${safeStringifyError(parseError)}`);\n                }\n            }\n            catch (fetchError) {\n                console.error('WordStream: Fetch error during translation:', safeStringifyError(fetchError));\n                throw new Error(`Fetch error: ${safeStringifyError(fetchError)}`);\n            }\n        }\n        catch (error) {\n            console.error('WordStream: Translation error:', safeStringifyError(error));\n            return {\n                success: false,\n                error: safeStringifyError(error)\n            };\n        }\n    });\n}\nfunction handleLanguageSettingsUpdate(settings) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        try {\n            console.log('WordStream: Updating language settings', settings);\n            if (!settings.targetLanguage) {\n                throw new Error('Target language is required');\n            }\n            const result = yield chrome.storage.sync.get(['settings']);\n            console.log('WordStream: Current settings', result.settings);\n            const currentSettings = result.settings || {};\n            const targetLanguage = settings.targetLanguage.toLowerCase().trim();\n            if (!targetLanguage) {\n                throw new Error('Invalid target language format');\n            }\n            const newSettings = Object.assign(Object.assign({}, currentSettings), { targetLanguage });\n            yield new Promise((resolve, reject) => {\n                chrome.storage.sync.set({ settings: newSettings }, () => {\n                    if (chrome.runtime.lastError) {\n                        reject(new Error(chrome.runtime.lastError.message));\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            });\n            // Verify the update\n            const verifyResult = yield chrome.storage.sync.get(['settings']);\n            console.log('WordStream: Verified settings after update', verifyResult.settings);\n            if (((_a = verifyResult.settings) === null || _a === void 0 ? void 0 : _a.targetLanguage) !== targetLanguage) {\n                throw new Error('Failed to verify settings update');\n            }\n            return { success: true };\n        }\n        catch (error) {\n            console.error('WordStream: Error updating language settings:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error'\n            };\n        }\n    });\n}\n// הגדרת קבועים לשימוש ב-API\nconst GEMINI_API_KEY = GEMINI_CONFIG.apiKey;\n// הוספת קבועים למודלים\nconst GEMINI_MODEL_PRIMARY = GEMINI_CONFIG.model;\nconst GEMINI_MODEL_FALLBACK = GEMINI_CONFIG.fallbackModel;\nconst GEMINI_MODEL_SECONDARY_FALLBACK = GEMINI_CONFIG.secondaryFallbackModel;\n// שימוש באינדקס API הסטנדרטי\nconst API_VERSIONS = ['v1'];\nfunction handleGeminiRequest(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const apiKey = GEMINI_API_KEY;\n        const GEMINI_MODEL = request.model || GEMINI_MODEL_PRIMARY;\n        const FALLBACK_MODEL = GEMINI_MODEL_FALLBACK;\n        const SECONDARY_FALLBACK_MODEL = GEMINI_MODEL_SECONDARY_FALLBACK;\n        if (!apiKey) {\n            console.error('[WordStream] Gemini API key is missing');\n            return { success: false, error: 'API key is missing' };\n        }\n        try {\n            console.log(`[WordStream] Processing Gemini request with model: ${GEMINI_MODEL}`);\n            // בדיקת API קיים ונגיש - נסיון לקבל את רשימת המודלים הזמינים\n            console.log('[WordStream] Checking available models');\n            const listModelsEndpoint = `https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`;\n            const listModelsResponse = yield fetch(listModelsEndpoint);\n            const modelsData = yield listModelsResponse.json();\n            // רשימת מודלים זמינים עבור הדיבוג\n            if (modelsData.models) {\n                const availableModels = modelsData.models.map((m) => m.name);\n                console.log('[WordStream] Available models:', availableModels.join(', '));\n                // בדוק אם המודל העיקרי זמין\n                if (!availableModels.includes(GEMINI_MODEL)) {\n                    console.warn(`[WordStream] Primary model ${GEMINI_MODEL} not found in available models. Will try fallback model.`);\n                }\n            }\n            else {\n                console.warn('[WordStream] Could not retrieve models list:', modelsData);\n            }\n            // יצירת endpoint דינמי לפי המודל הנבחר\n            // נשתמש ב-endpoint סטנדרטי של gemini במקום הגרסה הישנה\n            const apiVersion = API_VERSIONS[0];\n            const endpoint = `https://generativelanguage.googleapis.com/${apiVersion}/models/${GEMINI_MODEL}:generateContent?key=${apiKey}`;\n            // ייצור ההקשר משופר עם פרטי הסרטון\n            let contextPrompt = `You are WordStream's AI Assistant, a versatile, Claude-like educational assistant that helps users learn while watching videos. Follow these important guidelines:\n\n    1. RESPONSE STRUCTURE & ANSWER DEPTH:\n       - ALWAYS ANSWER FIRST, THEN CHECK USER SATISFACTION - Never respond with a question first unless absolutely necessary.\n       - Provide the best possible answer based on available data before asking if further clarification is needed.\n       - Do not shorten responses arbitrarily—answer as completely as possible.\n       - For complex topics, start with a complete answer and offer further depth if needed.\n       - For straightforward factual questions, provide a concise answer first and offer an option to elaborate if the user is interested.\n       - Never skip directly to asking a question without providing substantial information first.\n    \n    2. LANGUAGE & USER ADAPTATION:\n       - AUTOMATICALLY RESPOND IN THE USER'S LANGUAGE - If they write in Hebrew, respond in Hebrew; if English, respond in English.\n       - Never change languages unless explicitly requested by the user.\n       - Maintain awareness of the last 5-7 user messages to prevent redundant explanations.\n       - If the user follows up on a previous topic, understand and continue naturally.\n       - Extend memory retention when the user continues on the same topic, but reset context smoothly when a completely new topic is introduced.\n    \n    3. VIDEO-RELATED QUESTIONS:\n       - Recognize whether a question is about the video or general and respond accordingly.\n       - When answering timestamped video-related questions, analyze transcript context if available and provide specific insights rather than generic explanations.\n       - If direct video content is unavailable, infer meaning based on related context without speculating. Offer an educated guess only if clearly indicated as such.\n    \n    4. STRUCTURED RESPONSES & FORMATTING:\n       - Use clean, easy-to-read formatting with clear paragraphs or bullet points.\n       - Break down complex topics with headings for longer explanations.\n       - Highlight important keywords to make scanning easier.\n       - Provide full, structured responses by default unless the user requests a summary.\n    \n    5. HANDLING UNCERTAINTY & EDGE CASES:\n       - Never give false information—if you don't have enough data, offer related insights instead.\n       - Minimize \"I don't know\" responses by attempting to infer meaning and offer the most relevant answer possible.\n       - If uncertain, ask clarifying questions instead of giving vague responses.\n    \n    6. CONVERSATIONAL FLOW & ENGAGEMENT:\n       - Never drop topics abruptly.\n       - If a user moves between subjects, acknowledge the transition while keeping responses fluid.\n       - Limit follow-up prompts to once per conversation unless the user actively engages. If the user ignores a follow-up twice, stop prompting for further engagement.\n    \n    7. LANGUAGE LEARNING FOCUS:\n       - Adapt response complexity based on user proficiency. For beginners, simplify explanations; for advanced users, offer in-depth linguistic details.\n       - Provide educational insights like usage examples, synonyms, or pronunciation notes.\n       - Relate explanations to real-world usage scenarios to make learning practical.\n    \n    8. INTEGRATION WITH EXTENSION FEATURES:\n       - Only mention WordStream features when relevant to the conversation—avoid forcing feature suggestions unless they directly benefit the user’s current request.\n       - Offer learning tips that complement the extension's capabilities.\n    \n    9. PERSONALIZED LEARNING GUIDANCE:\n       - Recognize repeated topics from the same user and build upon previous explanations.\n       - Provide encouragement that motivates continued learning.\n    \n    Remember: Always answer first, then check satisfaction. Respond in the user's language. Maintain context with short responses. Structure information clearly. Handle uncertainty gracefully. Keep conversations flowing naturally. Focus on language learning value.`;\n            // הוסף פרטי הסרטון להקשר\n            if (request.videoTitle) {\n                contextPrompt += `\\n\\nThe user is watching the following video: \"${request.videoTitle}\"`;\n            }\n            if (request.videoContext) {\n                if (request.videoContext.description) {\n                    contextPrompt += `\\nVideo description: ${request.videoContext.description}`;\n                }\n                if (request.videoContext.channelName) {\n                    contextPrompt += `\\nChannel: ${request.videoContext.channelName}`;\n                }\n                if (request.videoContext.url) {\n                    contextPrompt += `\\nURL: ${request.videoContext.url}`;\n                }\n            }\n            // יצירת payload עם ההיסטוריה אם היא קיימת\n            let messages = [];\n            // הוסף הודעות מההיסטוריה\n            if (request.history && request.history.length > 0) {\n                messages = request.history.map(msg => ({\n                    role: msg.role,\n                    parts: [{ text: msg.content }]\n                }));\n            }\n            // הוסף את ההודעה הנוכחית של המשתמש\n            messages.push({\n                role: \"user\",\n                parts: [{ text: request.message }]\n            });\n            const payload = {\n                contents: [\n                    {\n                        role: \"user\",\n                        parts: [{ text: contextPrompt }]\n                    },\n                    ...messages.slice(-30) // הגדלנו את מספר ההודעות מ-20 ל-30 לזיכרון משופר של שיחות ארוכות\n                ],\n                generationConfig: {\n                    temperature: 0.75, // איזון בין יצירתיות לדיוק\n                    topK: 40,\n                    topP: 0.92,\n                    maxOutputTokens: 8192, // הגדלת אורך התשובה המקסימלי לתשובות ארוכות ומפורטות יותר\n                    stopSequences: [] // מאפשר לסיים תשובות בצורה טבעית יותר\n                },\n                safetySettings: [\n                    { category: \"HARM_CATEGORY_HARASSMENT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\" },\n                    { category: \"HARM_CATEGORY_HATE_SPEECH\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\" },\n                    { category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\" },\n                    { category: \"HARM_CATEGORY_DANGEROUS_CONTENT\", threshold: \"BLOCK_MEDIUM_AND_ABOVE\" }\n                ]\n            };\n            console.log(`[WordStream] Sending request to Gemini API: ${endpoint}`);\n            // לוגים מורחבים לצורך דיבוג\n            console.log('[WordStream] Gemini payload:', JSON.stringify(payload, null, 2).substring(0, 500) + '...');\n            const response = yield fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(payload)\n            });\n            if (!response.ok) {\n                const errorData = yield response.text();\n                console.error(`[WordStream] Gemini API error (${response.status}):`, errorData);\n                // בדוק אם זו שגיאת 404 ונסה ליפול חזרה למודל הראשון\n                if (response.status === 404 && GEMINI_MODEL !== FALLBACK_MODEL) {\n                    console.log(`[WordStream] Trying primary fallback model: ${FALLBACK_MODEL}`);\n                    // קרא שוב לפונקציה עם מודל אחר\n                    const fallbackRequest = Object.assign(Object.assign({}, request), { model: FALLBACK_MODEL });\n                    return handleGeminiRequest(fallbackRequest);\n                }\n                // בדוק אם זו שגיאת 404 עם מודל הגיבוי הראשון ונסה ליפול חזרה למודל הגיבוי השני\n                if (response.status === 404 && GEMINI_MODEL === FALLBACK_MODEL && FALLBACK_MODEL !== SECONDARY_FALLBACK_MODEL) {\n                    console.log(`[WordStream] Trying secondary fallback model: ${SECONDARY_FALLBACK_MODEL}`);\n                    // קרא שוב לפונקציה עם מודל הגיבוי השני\n                    const secondaryFallbackRequest = Object.assign(Object.assign({}, request), { model: SECONDARY_FALLBACK_MODEL });\n                    return handleGeminiRequest(secondaryFallbackRequest);\n                }\n                return {\n                    success: false,\n                    error: `Gemini API error (${response.status}): ${errorData}`\n                };\n            }\n            const data = yield response.json();\n            console.log('[WordStream] Gemini API response:', data);\n            if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {\n                return {\n                    success: false,\n                    error: 'Empty response from Gemini API'\n                };\n            }\n            // חלץ את התשובה מהמודל\n            const answer = data.candidates[0].content.parts[0].text;\n            return {\n                success: true,\n                answer\n            };\n        }\n        catch (error) {\n            console.error('[WordStream] Error in Gemini request:', error);\n            return {\n                success: false,\n                error: `Error processing request: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    });\n}\n"],"names":[],"sourceRoot":""}